I want to get this thing going, right now. Enough researching - I know what the path forward is. The hardest part is gonna be setting up the tooling to bootstrap loop-kit. loop-kit should be built with itself, basically. But starting out that might not be possible.

Also for now, let's abandon the idea of non-WASM components. They will either be components, or hosts provided by loop-kit, including the browser. They won't load new native code somehow. There will be ways to get all sorts of code compatible with WASM components though. Like using a WASM component that's a "provider" e.g. talks through wRPC to an exe running.

A really important thing is how this is all build and configured. I'm researching wit-deps, [wasm-component-ld](https://github.com/bytecodealliance/wasm-component-ld), [this](https://docs.rs/wit-component/latest/wit_component/index.html) and **_[this](https://docs.rs/wit-component/latest/wit_component/struct.ComponentEncoder.html)_**, was-sdk ([WebAssembly/wasi-sdk: WASI-enabled WebAssembly C/C++ toolchain](https://github.com/WebAssembly/wasi-sdk)) and more.

I hate software tooling for big workspaces like this. A massive goal of loop-kit is to be a solution for code project management, monorepo-style or polyrepo-style too. That's a neglected part in this research. The important part is the CLI, then. The CLI needs to be completely plugin-based. The goal for loop-kit overall is to make it trivial to make some functionality driven by plugins - and importantly, with the ability to configure a lot about those plugins, and the "slot" for the plugins - meaning defaults, or the mechanism by which plugins are fetched, loaded, etc.

Epic solution: make the code to build your project, work with WASM components, etc. part of the core loop runtime, or part of "provider" WASM components or executables (for native providers over wRPC, or maybe Docker over wRPC). The importa1nt stuff is all defined in your codebase itself. As components, how about? I'm really leaning into this "everything is a component" concept with loop-kit. Do not worry about overhead or performance yet! This is all a proof of concept.

Also, we should have conventions for things like configuration files. I like TOML, but that doesn't matter as much as being able to make senes of how to wire up a loop-kit application. We need conventions for what components handle what. How about this - components have identifiers, and you just use that. Could be a local filepath (relative or absolute), a URL, or an OCI URI or however that works. With this ability, we can easily have defaults, or load new ones dynamically at runtime/build time, etc. Using components for scripting your build & dev scripts and whatnot makes so much sense. It's all code - 1000x better than cobbling together a bunch of random tools (nodemon, webpack - don't even get me started). Also, the WASM capability system is perfect for reproducible builds, or figuring out exactly what went wrong, or for example being able to automatically see if part of your build process needs network access capabilities. Another thing though - WASM components could be held in memory and dynamically switched for something else. This is pretty important actually. The plugin (comp) that handles some behavior could be arbitrarily resolved at runtime. So for example, the CLI could pull from a persistent SQLite database or JSON file really easily. So it can remember the plugins you add. And you can swap or add new ones while still running it, recompile them, etc. So the runtime will support all this. But some of it is considered "higher-level" stuff and can be implemented with WASM components to provide more simple, elegant APIs. But the core of it is mostly just simple Wasmtime type stuff. Getting component bytes, loading it. That's it.

That's the core - but what about the actual dev workflow? Well, it's all component driven - and in this case the default components that I actually ship for loop-kit will do certain specific things, and of course these can be composed of smaller components - and all of them can be used in a custom version of a plugin, e.g. as an API. Important: loop-kit CLI by default will have a super handy system of being able to fork components, and give you source code to work with (not the literal source code but formatted generated bindings in your language of choice).

Another big part of the CLI is dependency management, of course. That's probably the hardest part of something like this. Key concept - loop-kit is realtime, incrementally updateable, and has insanely strong typing inherently, forced through WASM component model. So we can detect if auto-updating a component won't work, or won't fit the interface. We can also add a system in loop-kit to add a migration provider and compose it with our component to become one component. One of my favorite JS projects Jazz just does this with a .withMigration function on collections, with can kinda be thought of similar to WASM components because they're heavy on schema and contracts, and don't actually store data itself but instead get it from some kind of provider.

I just want to get the core of loop-kit done so that I can experiment with these more complicated high-level decisions like dependency management, version control integration, build task orchestration, etc.

A lot of what I'm saying seems like a complicated way to explain a simple concept, but the details are really important because it gets complicated and messy fast. I think that this is true with all code build-system type projects. I suspect the problem is because you're trying to basically use a really shitty arbitrary mix of languages with no clue about your project or code to build it - literally, people use bash or package.json, or opinionated tools with no flexibility. Not in loop-kit! Everything's programmable, especially your dev/build/etc. process. Define it in your lk workspace, same place you define all other code related to your project. This means you can share code - easily. Even in a polyrepo situation this works great, because WASM component dependencies can be an OCI URI or literally anything. Also important: the loop-kit CLI should be intended to hack apart, and redistribute. In fact instead of pushing an executable, we could push loop-kit as a single component, and you just install it + put on path via a lightweight installer that can do the same with any component you want - so organizations could easily just fork it and configure it their own way.

Important note though - we gotta make sure we're signing WASM components and treating them like important protected resources, and stuff. WIT does guarantee a ton of safety, but still.

In conclusion: next big step in loop-kit is figuring out how to build the CLI. But actually that's the easy part - the real question is how to we build the native runtime that the CLI runs in, and how do we make it so that native runtime can load that component in to act as the CLI (securely!). And how do we provide the installation method for the loop-kit CLI. I mean, there's a simpler way to do all of this. Make the CLI a custom host. Make loop-kit more like an SDK. Remember? Did I go too far down the rabbit hole of WASM comps? I think the real rabbit hole is my obsession with infinite composability, transparency, etc. But overengineering this might be worse than just having users who want their own CLI fork a Github project and build it with Rust. Damn. That's definitely a lot simpler. We don't have to manage hundreds of moving parts that are all WASM components.

What I'm really doing is trying ot figure out the future of programming, which is incrementalism.

But before we begin implementing examples, we need a host to run them in. And probably a CLI to streamline running them. Should this all be Rust? I do like JS a bit more because it's simple and I'm more familiar with it. Also, there's legacy code in /packages. CLI and registry. The site is ok, I'll refactor it to use loop-kit in the future, just ignore it for now. reg & CLI basically do nothing by the way. Also, I would like to implement even the loop CLI as a wasm component, with a built-in

I want to start with windowing & graphics, because the visual feedback will give me hope.

Update README, AGENTS.md, and /knowledge relevant docs with the changes in loop-kit architecture I outlined here.
