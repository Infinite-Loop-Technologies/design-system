//! Generated by loop-cli for project: {{ project_name }}

mod bindings {
    //! This module contains generated code for implementing
    //! the `app` world in `wit/world.wit`.
    
    wit_bindgen::generate!({
        path: "wit",
        world: "app",
    });
    
    // Re-export our component implementation
    use super::{{ struct_name }};
    export!({{ struct_name }});
}

// Import the generated types and traits
use bindings::{Guest, log};
use bindings::wasi::{
    frame_buffer::frame_buffer,
    graphics_context::graphics_context,
    surface::surface,
};

/// Main component struct
struct {{ struct_name }};

impl Guest for {{ struct_name }} {
    fn start() {
        log("Hello from loop-kit!");
        draw_window();
    }
}

fn draw_window() {
    // Create a window
    let canvas = surface::Surface::new(surface::CreateDesc {
        height: Some(600),
        width: Some(800),
    });

    // Create graphics context
    let ctx = graphics_context::Context::new();
    canvas.connect_graphics_context(&ctx);

    // Create frame buffer
    let fb = frame_buffer::Device::new();
    fb.connect_graphics_context(&ctx);

    // Subscribe to events
    let frame_pollable = canvas.subscribe_frame();
    let resize_pollable = canvas.subscribe_resize();
    let pointer_up_pollable = canvas.subscribe_pointer_up();

    let pollables = vec![&frame_pollable, &resize_pollable, &pointer_up_pollable];

    let mut width = canvas.width();
    let mut height = canvas.height();

    log(&format!("Window created: {}x{}", width, height));

    loop {
        let ready = bindings::wasi::io::poll::poll(&pollables);

        if ready.contains(&1) {
            let event = canvas.get_resize().unwrap();
            width = event.width;
            height = event.height;
            log(&format!("Resized: {}x{}", width, height));
        }

        if ready.contains(&2) {
            let event = canvas.get_pointer_up();
            log(&format!("Click at: {:?}", event));
        }

        if ready.contains(&0) {
            canvas.get_frame();

            let graphics_buffer = ctx.get_current_buffer();
            let buffer = frame_buffer::Buffer::from_graphics_buffer(graphics_buffer);

            // Fill with a gradient
            let mut pixels = vec![0u32; (width * height) as usize];
            for y in 0..height {
                for x in 0..width {
                    let r = (x * 255 / width.max(1)) as u32;
                    let g = (y * 255 / height.max(1)) as u32;
                    let b = 128u32;
                    pixels[(y * width + x) as usize] = (r << 16) | (g << 8) | b;
                }
            }

            buffer.set(bytemuck::cast_slice(&pixels));
            ctx.present();
        }
    }
}